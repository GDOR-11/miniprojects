{
  "version": 3,
  "sources": ["../../node_modules/vecti/dist/index.mjs", "../../src/infinite_minesweeper/tile.ts", "../../src/infinite_minesweeper/screen_view.ts", "../../src/infinite_minesweeper/utils.ts", "../../src/infinite_minesweeper/minefield.ts", "../../src/infinite_minesweeper/solvers.ts", "../../src/infinite_minesweeper/index.ts"],
  "sourcesContent": ["var e = Object.defineProperty;\nvar y = (h, t, s) => t in h ? e(h, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : h[t] = s;\nvar n = (h, t, s) => y(h, typeof t != \"symbol\" ? t + \"\" : t, s);\nclass i {\n  /**\n   * Create a vector with the given components.\n   * @param x - The component of the x-axis.\n   * @param y - The component of the y-axis.\n   * @returns The vector.\n   */\n  constructor(t, s) {\n    n(this, \"x\");\n    n(this, \"y\");\n    this.x = t, this.y = s;\n  }\n  /**\n   * Create a vector with the given components.\n   * @param x - The component of the x-axis.\n   * @param y - The component of the y-axis.\n   * @returns The vector.\n   */\n  static of([t, s]) {\n    return new i(t, s);\n  }\n  /**\n   * Add another vector to the vector.\n   * @param val - The vector to be added.\n   * @returns The resulting vector of the addition.\n   */\n  add(t) {\n    return new i(this.x + t.x, this.y + t.y);\n  }\n  /**\n   * Subtract another vector from the vector.\n   * @param val - The vector to be added.\n   * @returns The resulting vector of the subtraction.\n   */\n  subtract(t) {\n    return new i(this.x - t.x, this.y - t.y);\n  }\n  /**\n   * Multiply the vector by a scalar.\n   * @param scalar - The scalar the vector will be multiplied by.\n   * @returns The resulting vector of the multiplication.\n   */\n  multiply(t) {\n    return new i(this.x * t, this.y * t);\n  }\n  /**\n   * Divide the vector by a scalar.\n   * @param scalar - The scalar the vector will be divided by.\n   * @returns The resulting vector of the division.\n   */\n  divide(t) {\n    return new i(this.x / t, this.y / t);\n  }\n  /**\n   * Calculate the dot product of the vector and another vector.\n   * @param other - The other vector used for calculating the dot product.\n   * @returns The dot product.\n   */\n  dot(t) {\n    return this.x * t.x + this.y * t.y;\n  }\n  /**\n   * Calculate the cross product of the vector and another vector. The cross product of two vectors `a` and `b` is defined as `a.x * b.y - a.y * b.x`.\n   * @param other - The other vector used for calculating the cross product.\n   * @returns The cross product.\n   */\n  cross(t) {\n    return this.x * t.y - t.x * this.y;\n  }\n  /**\n   * Calculate the Hadamard product of the vector and another vector.\n   * @param other - The other vector used for calculating the Hadamard product.\n   * @returns The Hadamard product.\n   */\n  hadamard(t) {\n    return new i(this.x * t.x, this.y * t.y);\n  }\n  /**\n   * Calculate the length of the vector using the L2 norm.\n   * @returns The length.\n   */\n  length() {\n    return Math.sqrt(this.x ** 2 + this.y ** 2);\n  }\n  /**\n   * Normalize the vector using the L2 norm.\n   * @returns The normalized vector.\n   */\n  normalize() {\n    const t = this.length();\n    return new i(this.x / t, this.y / t);\n  }\n  /**\n   * Rotate the vector by the given radians counterclockwise.\n   * @param radians - The radians the vector will be rotated by.\n   * @returns The rotated vector.\n   */\n  rotateByRadians(t) {\n    const s = Math.cos(t), r = Math.sin(t);\n    return new i(this.x * s - this.y * r, this.x * r + this.y * s);\n  }\n  /**\n   * Rotate the vector by the given degrees counterclockwise.\n   * @param degrees - The degrees the vector will be rotated by.\n   * @returns The rotated vector.\n   */\n  rotateByDegrees(t) {\n    return this.rotateByRadians(t * Math.PI / 180);\n  }\n}\nexport {\n  i as Vector\n};\n", "import { difficulty } from \".\";\n\nexport enum TileState {\n    Unknown,\n    Flagged,\n    Revealed\n}\n\nexport default class Tile {\n    state: TileState;\n    mine: boolean;\n\n    constructor(state: TileState = TileState.Unknown, mine: boolean = Math.random() < difficulty) {\n        this.state = state;\n        this.mine = mine;\n    }\n}\n", "import { Vector } from \"vecti\";\n\nexport let view_center = new Vector(0, 0);\nexport let view_zoom = 50;\n\nexport function setViewCenter(new_center: Vector) {\n    view_center = new_center;\n}\nexport function setViewZoom(new_zoom: number) {\n    view_zoom = new_zoom;\n}\n\nconst screen_center = new Vector(window.innerWidth, window.innerHeight).divide(2);\n\nexport function world2screen(world: number): number;\nexport function world2screen(world: Vector): Vector;\nexport function world2screen(world: number | Vector): number | Vector {\n    return typeof world === \"number\" ? world * view_zoom : world.subtract(view_center).multiply(view_zoom).add(screen_center);\n}\n\nexport function screen2world(screen: number): number;\nexport function screen2world(screen: Vector): Vector;\nexport function screen2world(screen: number | Vector): number | Vector {\n    return typeof screen === \"number\" ? screen / view_zoom : screen.subtract(screen_center).divide(view_zoom).add(view_center);\n}\n\nexport function screen2world_round(screen: Vector) {\n    let world = screen2world(screen);\n    return new Vector(Math.round(world.x), Math.round(world.y));\n}\n", "import { Vector } from \"vecti\";\n\nexport function neighborhood(center: Vector): Vector[] {\n    let neighborhood = [];\n    for (let x = center.x - 1; x <= center.x + 1; x++) {\n        for (let y = center.y - 1; y <= center.y + 1; y++) {\n            if (x === center.x && y === center.y) continue;\n            neighborhood.push(new Vector(x, y));\n        }\n    }\n    return neighborhood;\n}\n", "import { Vector } from \"vecti\";\nimport Tile, { TileState } from \"./tile\";\nimport { screen2world_round, view_zoom, world2screen } from \"./screen_view\";\nimport { neighborhood } from \"./utils\";\n\nexport default class Minefield {\n    /** top left */ a: Vector;\n    /** bottom right */ b: Vector;\n\n    field: { [x: number]: { [y: number]: Tile } };\n\n    constructor() {\n        this.a = new Vector(-1, -1);\n        this.b = new Vector(1, 1);\n        this.field = { [-1]: {}, 0: {}, 1: {} };\n        for (let pos of neighborhood(new Vector(0, 0))) {\n            this.field[pos.x][pos.y] = new Tile(TileState.Unknown, false);\n        }\n        this.field[0][0] = new Tile(TileState.Revealed, false);\n    }\n\n    getTile(coordinate: Vector): Tile | undefined {\n        return this.field?.[coordinate.x]?.[coordinate.y];\n    }\n\n    getTileState(coordinate: Vector): TileState {\n        return this.getTile(coordinate)?.state || TileState.Unknown;\n    }\n\n    getNeighborMineCount(coordinate: Vector): number {\n        let count = 0;\n        for (let neighbor of neighborhood(coordinate)) {\n            count += this.getTile(neighbor)?.mine ? 1 : 0;\n        }\n        return count;\n    }\n\n    getOuterBorderTiles(): Vector[] {\n        let queue = (() => {\n            let pos = new Vector(0, this.a.y);\n            while (this.getTile(pos).state !== TileState.Revealed) pos = new Vector(0, pos.y + 1);\n            return [pos];\n        })();\n        let tiles = queue.slice();\n        let is_border_tile = (pos: Vector) => neighborhood(pos).find(neighbor => this.getTileState(neighbor) === TileState.Unknown) !== undefined;\n        while (queue.length > 0) {\n            \n        }\n    }\n\n    expandField(left: number, right: number, top: number, bottom: number) {\n        this.a = this.a.subtract(new Vector(left, top));\n        this.b = this.b.add(new Vector(right, bottom));\n        for (let x = this.a.x; x <= this.b.x; x++) {\n            this.field[x] ??= {};\n            for (let y = this.a.y; y <= this.b.y; y++) {\n                this.field[x][y] ??= new Tile();\n            }\n        }\n    }\n\n    expandToTile(coordinate: Vector) {\n        if (coordinate.x - 1 < this.a.x) this.expandField(1 + this.a.x - coordinate.x, 0, 0, 0);\n        if (coordinate.x + 1 > this.b.x) this.expandField(0, 1 + coordinate.x - this.b.x, 0, 0);\n        if (coordinate.y - 1 < this.a.y) this.expandField(0, 0, 1 + this.a.y - coordinate.y, 0);\n        if (coordinate.y + 1 > this.b.y) this.expandField(0, 0, 0, 1 + coordinate.y - this.b.y);\n    }\n\n    setTileState(coordinate: Vector, state: TileState): Tile {\n        this.expandToTile(coordinate);\n        let tile = this.getTile(coordinate);\n        if (tile === null) throw \"what the fuck\";\n        tile.state = state;\n        return tile;\n    }\n\n    detailed_render(ctx: CanvasRenderingContext2D) {\n        let A = screen2world_round(new Vector(0, 0));\n        let B = screen2world_round(new Vector(window.innerWidth, window.innerHeight));\n\n        ctx.strokeStyle = \"grey\";\n        for (let x = A.x - 0.5; x <= B.x + 0.5; x++) {\n            let screen_x = world2screen(new Vector(x, 0)).x;\n            ctx.beginPath();\n            ctx.moveTo(screen_x, 0);\n            ctx.lineTo(screen_x, window.innerHeight);\n            ctx.stroke();\n        }\n        for (let y = A.y - 0.5; y <= B.y + 0.5; y++) {\n            let screen_y = world2screen(new Vector(0, y)).y;\n            ctx.beginPath();\n            ctx.moveTo(0, screen_y);\n            ctx.lineTo(window.innerWidth, screen_y);\n            ctx.stroke();\n        }\n\n        const text_size = 0.75;\n\n        for (let x = A.x; x <= B.x; x++) {\n            for (let y = A.y; y <= B.y; y++) {\n                let pos = new Vector(x, y);\n                let pixel = world2screen(pos);\n\n                let text = \"\";\n                switch (this.getTileState(pos)) {\n                    case TileState.Flagged:\n                        ctx.fillStyle = \"blue\";\n                        text = \"F\";\n                        break;\n                    case TileState.Revealed:\n                        let mine = this.getTile(pos).mine;\n                        ctx.fillStyle = mine ? \"red\" : \"white\";\n                        text = mine ? \"M\" : this.getNeighborMineCount(pos).toString();\n                        break;\n                }\n                if (text === \"\") continue;\n\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"top\";\n                ctx.font = world2screen(text_size) + \"px monospace\";\n                ctx.fillText(text, pixel.x, pixel.y - world2screen(7 * text_size / 16));\n            }\n        }\n    }\n\n    simple_render(ctx: CanvasRenderingContext2D) {\n        let tile_sidelength = world2screen(1);\n        for (let i in this.field) {\n            let x = Number(i);\n            let row = this.field[x];\n            for (let j in row) {\n                let y = Number(j);\n                let tile = row[y];\n                if (tile.state === TileState.Unknown) continue;\n\n                let screen = world2screen(new Vector(x, y));\n                if (screen.x < -10) break;\n                if (screen.x > window.innerWidth + 10) break;\n                if (screen.y < -10) continue;\n                if (screen.y > window.innerHeight + 10) continue;\n\n                if (tile.state === TileState.Flagged) ctx.fillStyle = \"blue\";\n                if (tile.state === TileState.Revealed) ctx.fillStyle = tile.mine ? \"red\" : \"white\";\n\n                ctx.fillRect(screen.x - tile_sidelength / 2, screen.y - tile_sidelength / 2, tile_sidelength, tile_sidelength);\n            }\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (view_zoom > 10) {\n            this.detailed_render(ctx);\n        } else {\n            this.simple_render(ctx);\n        }\n    }\n}\n", "import { Vector } from \"vecti\";\nimport Minefield from \"./minefield\";\nimport { TileState } from \"./tile\";\nimport { neighborhood } from \"./utils\";\n\nexport async function brainlessSolver(minefield: Minefield, on_update: () => Promise<any>) {\n    let queue = [new Vector(0, 0)];\n    let on_new_information = async (pos: Vector) => {\n        for (let neighbor of neighborhood(pos).concat([pos])) {\n            if (queue.find(p => p.x === neighbor.x && p.y === neighbor.y) !== undefined) continue;\n            queue.push(neighbor);\n        }\n        await on_update();\n    }\n    while (queue.length > 0) {\n        let pos = queue[0];\n        if (minefield.getTileState(pos) !== TileState.Revealed || minefield.getNeighborMineCount(pos) !== 0) {\n            queue.shift();\n            continue;\n        }\n        for (let neighbor of neighborhood(pos)) {\n            if (minefield.getTileState(neighbor) !== TileState.Unknown) continue;\n            minefield.setTileState(neighbor, TileState.Revealed);\n            await on_new_information(neighbor);\n        }\n        queue.shift();\n    }\n}\n\nexport async function trivialSolver(minefield: Minefield, on_update: () => Promise<any>) {\n    let queue = [];\n    let on_new_information = async (pos: Vector) => {\n        for (let neighbor of neighborhood(pos).concat([pos])) {\n            if (queue.find(p => p.x === neighbor.x && p.y === neighbor.y) !== undefined) continue;\n            queue.push(neighbor);\n        }\n        await on_update();\n    }\n    while (queue.length > 0) {\n        let pos = queue[0];\n        if (minefield.getTileState(pos) !== TileState.Revealed) {\n            queue.shift();\n            continue;\n        }\n        let unknown_count = 0;\n        let flag_count = 0;\n        for (let neighbor of neighborhood(pos)) {\n            let state = minefield.getTileState(neighbor);\n            if (state === TileState.Unknown) unknown_count++;\n            if (state === TileState.Flagged) flag_count++;\n        }\n        let mine_count = minefield.getNeighborMineCount(pos);\n        if (unknown_count === mine_count - flag_count) {\n            for (let neighbor of neighborhood(pos)) {\n                let state = minefield.getTileState(neighbor);\n                if (state === TileState.Unknown) {\n                    minefield.setTileState(neighbor, TileState.Flagged);\n                    await on_new_information(neighbor);\n                }\n            }\n        }\n        if (flag_count === mine_count) {\n            for (let neighbor of neighborhood(pos)) {\n                let state = minefield.getTileState(neighbor);\n                if (state === TileState.Unknown) {\n                    minefield.setTileState(neighbor, TileState.Revealed);\n                    await on_new_information(neighbor);\n                }\n            }\n        }\n        queue.shift();\n    }\n}\n\nexport async function bestStrategy(minefield: Minefield, on_update: () => Promise<any>) {\n    let updated = false;\n    let update = async () => {\n        updated = true;\n        await on_update();\n    };\n    while(updated) {\n        updated = false;\n        trivialSolver();\n    }\n}\n", "import { Vector } from \"vecti\";\nimport \"./index.css\";\nimport Minefield from \"./minefield\";\nimport { screen2world, screen2world_round, setViewCenter, setViewZoom, view_center, view_zoom } from \"./screen_view\";\nimport { TileState } from \"./tile\";\nimport { brainlessSolver, trivialSolver } from \"./solvers\";\n\nexport const difficulty = Number(prompt(\"difficulty [0-1]\"));\n\nconst canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nconst ctx = canvas.getContext(\"2d\");\n\nlet minefield = new Minefield();\n\nfunction render() {\n    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n    minefield.render(ctx);\n}\n\nfunction resize() {\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n    render();\n}\nwindow.onresize = resize;\nresize();\n\nfunction click(coordinate: Vector) {\n    switch (minefield.getTileState(coordinate)) {\n        case TileState.Unknown:\n            minefield.setTileState(coordinate, TileState.Revealed);\n            break;\n        case TileState.Flagged:\n            break;\n        case TileState.Revealed:\n            break;\n    }\n}\nfunction long_press(coordinate: Vector) {\n    switch (minefield.getTileState(coordinate)) {\n        case TileState.Unknown:\n            minefield.setTileState(coordinate, TileState.Flagged);\n            break;\n        case TileState.Flagged:\n            minefield.setTileState(coordinate, TileState.Unknown);\n            break;\n        case TileState.Revealed:\n            break;\n    }\n}\n\ntype Pointer = {\n    last_pos: Vector,\n    total_distance: number,\n    /** Date.now() when the pointer was pressed */\n    pressed: number\n};\n\nlet pointers: { [pointerId: number]: Pointer } = {};\n\nwindow.onpointerdown = event => {\n    pointers[event.pointerId] = {\n        last_pos: new Vector(event.x, event.y),\n        total_distance: 0,\n        pressed: Date.now()\n    };\n    // setTimeout(() => {\n    //     if (pointers[event.pointerId]?.total_distance < 10 && Object.keys(pointers).length === 1) {\n    //         let pos = pointers[event.pointerId].last_pos;\n    //         let coordinates = screen2world_round(pos);\n    //         long_press(coordinates);\n    //         render();\n    //     }\n    // }, 125);\n}\nwindow.onpointermove = event => {\n    let moved_pointer = pointers[event.pointerId];\n    let pos = new Vector(event.x, event.y);\n    let last_pos = moved_pointer.last_pos;\n    moved_pointer.total_distance += pos.subtract(moved_pointer.last_pos).length();\n    moved_pointer.last_pos = pos;\n\n    if (moved_pointer.total_distance < 10) return;\n    switch (Object.keys(pointers).length) {\n        case 1:\n            let movement = new Vector(screen2world(event.movementX), screen2world(event.movementY));\n            setViewCenter(view_center.subtract(movement));\n            break;\n        case 2:\n            let anchor_id = parseInt(Object.keys(pointers).filter(id => id !== event.pointerId + \"\")[0]);\n            let anchor_pointer = pointers[anchor_id];\n            let center_movement = screen2world(pos).subtract(screen2world(last_pos)).divide(2);\n            let amplification = pos.subtract(anchor_pointer.last_pos).length() / last_pos.subtract(anchor_pointer.last_pos).length();\n            setViewCenter(view_center.subtract(center_movement));\n            setViewZoom(view_zoom * amplification);\n            break;\n    }\n    // we could render, but since rendering is so expensive we don't do that in here\n    // render();\n}\nwindow.onpointerup = event => {\n    // let pointer = pointers[event.pointerId];\n    // if (pointer.total_distance < 10) {\n    //     let coordinates = screen2world_round(pointer.last_pos);\n    //     if (Date.now() - pointer.pressed < 125) {\n    //         click(coordinates);\n    //     }\n    //     render();\n    // }\n    delete pointers[event.pointerId];\n};\n\n(async () => {\n    while (true) {\n        minefield = new Minefield();\n        let last_update = Date.now();\n        await trivialSolver(minefield, async () => {\n            if (Date.now() - last_update > 100) {\n                render();\n                await new Promise(r => setTimeout(r, 1));\n                last_update = Date.now();\n            }\n        });\n        render();\n        await new Promise(r => setTimeout(r, 1));\n    }\n})();\n"],
  "mappings": "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",
  "names": ["neighborhood", "y", "y", "ctx", "i", "minefield"]
}
